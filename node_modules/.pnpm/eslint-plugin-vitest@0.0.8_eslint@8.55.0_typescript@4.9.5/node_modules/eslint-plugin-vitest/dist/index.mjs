import { ESLintUtils } from '@typescript-eslint/utils';

const createEslintRule = ESLintUtils.RuleCreator((ruleName) => ruleName);

const RULE_NAME$5 = "assertion-type";
const assertionType = createEslintRule({
  name: RULE_NAME$5,
  meta: {
    type: "problem",
    docs: {
      description: "Enforce assertion type",
      recommended: "error"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          type: {
            type: "string",
            enum: ["jest", "chai"]
          }
        },
        additionalProperties: false
      }
    ],
    messages: {
      assertionType: "Assertion type should be {{type}}."
    }
  },
  defaultOptions: [
    {
      type: "jest"
    }
  ],
  create(context, [{ type }]) {
    const assertionType = type === "jest" ? "expect" : "assert";
    return {
      ExpressionStatement(node) {
        if (node.expression.type === "CallExpression" && node.expression.callee.type === "Identifier") {
          if (node.expression.callee.name === assertionType) {
            const { arguments: args } = node.expression;
            if (args[0].type === "Identifier" && args[0].name !== "t") {
              context.report({
                node,
                messageId: "assertionType",
                data: {
                  type
                }
              });
            }
          }
        }
      }
    };
  }
});

const RULE_NAME$4 = "lower-case-title";
const lowerCaseTitle = createEslintRule({
  name: RULE_NAME$4,
  meta: {
    type: "problem",
    docs: {
      description: "Enforce lowercase titles",
      recommended: "error"
    },
    fixable: "code",
    schema: [],
    messages: {
      lowerCaseTitle: "Title should be lowercase."
    }
  },
  defaultOptions: [],
  create: (context) => {
    const reserved = ["it", "describe", "test"];
    function isLowerCase(str) {
      return str == str.toLowerCase() && str != str.toUpperCase();
    }
    return {
      ExpressionStatement(node) {
        if (node.expression.type === "CallExpression" && node.expression.callee.type === "Identifier") {
          if (reserved.includes(node.expression.callee.name)) {
            const { arguments: args } = node.expression;
            if (args[0].type === "Literal" && typeof args[0].value === "string" && !isLowerCase(args[0].value)) {
              context.report({
                node,
                messageId: "lowerCaseTitle"
              });
            }
          }
        }
      }
    };
  }
});

const RULE_NAME$3 = "max-nested-describe";
const maxNestedDescribe = createEslintRule({
  name: RULE_NAME$3,
  meta: {
    type: "problem",
    docs: {
      description: "Disallow nested describes",
      recommended: "error"
    },
    fixable: "code",
    schema: [
      {
        type: "object",
        properties: {
          max: {
            type: "number"
          }
        },
        additionalProperties: false
      }
    ],
    messages: {
      maxNestedDescribe: "Nested describes are not allowed."
    }
  },
  defaultOptions: [
    {
      max: 5
    }
  ],
  create(context, [{ max }]) {
    const stack = [];
    return {
      "CallExpression[callee.name='describe']"(node) {
        if (stack.length >= max) {
          context.report({
            node,
            messageId: "maxNestedDescribe"
          });
        }
        stack.push(node);
      }
    };
  }
});

const RULE_NAME$2 = "no-conditional-in-tests";
const noConditionalInTest = createEslintRule({
  name: RULE_NAME$2,
  meta: {
    type: "problem",
    docs: {
      description: "Disallow conditional statements in tests",
      recommended: "error"
    },
    fixable: "code",
    schema: [],
    messages: {
      noConditionalInTests: "Conditional statements are not allowed in tests."
    }
  },
  defaultOptions: [],
  create: (context) => {
    return {
      ExpressionStatement(node) {
      }
    };
  }
});

const RULE_NAME$1 = "no-identical-title";
const noIdenticalTitle = createEslintRule({
  name: RULE_NAME$1,
  meta: {
    type: "problem",
    docs: {
      description: "Disallow identical titles",
      recommended: "error"
    },
    fixable: "code",
    schema: [],
    messages: {
      noIdenticalTitle: "Identical titles are not allowed."
    }
  },
  defaultOptions: [],
  create(context) {
    const stack = [];
    return {
      ExpressionStatement(node) {
        if (node.expression.type === "CallExpression" && node.expression.callee.type === "Identifier" && node.expression.callee.name === "describe") {
          const { arguments: args } = node.expression;
          if (args[1].type === "FunctionExpression") {
            const {
              body: { body }
            } = args[1];
            if (body.length > 0) {
              body.forEach((node2) => {
                if (node2.type === "ExpressionStatement" && node2.expression.type === "CallExpression" && node2.expression.callee.type === "Identifier" && (node2.expression.callee.name === "it" || node2.expression.callee.name === "describe")) {
                  const { arguments: args2 } = node2.expression;
                  if (args2.length > 0) {
                    if (args2[0].type === "Literal") {
                      const title = args2[0].value;
                      if (stack.includes(title)) {
                        context.report({
                          node: node2,
                          messageId: "noIdenticalTitle"
                        });
                      }
                      stack.push(title);
                    }
                  }
                }
              });
            }
          }
        }
      }
    };
  }
});

const RULE_NAME = "no-skipped-tests";
const noSkippedTests = createEslintRule({
  name: RULE_NAME,
  meta: {
    type: "problem",
    docs: {
      description: "Disallow skipped tests",
      recommended: "error"
    },
    fixable: "code",
    schema: [],
    messages: {
      noSkippedTests: "Skipped tests are not allowed."
    }
  },
  defaultOptions: [],
  create: (context) => {
    return {
      ExpressionStatement(node) {
        if (node.expression.type === "CallExpression") {
          const { callee } = node.expression;
          if (callee.type === "MemberExpression" && callee.object.type === "Identifier" && callee.object.name === "it" && callee.property.type === "Identifier" && callee.property.name === "skip") {
            context.report({
              node,
              messageId: "noSkippedTests"
            });
          }
        }
      }
    };
  }
});

const index = {
  rules: {
    "no-skip-test": noSkippedTests,
    "lower-case-title": lowerCaseTitle,
    "assertion-type": assertionType,
    "max-nested-describe": maxNestedDescribe,
    "no-idential-title": noIdenticalTitle,
    "no-conditional-in-test": noConditionalInTest
  }
};

export { index as default };
